<!DOCTYPE html>
<html>
<head>
    <title>Load Visualization Test</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
        }
        .test-container {
            background: #f5f5f5;
            padding: 40px;
            border-radius: 8px;
        }
        .beam-line {
            stroke: #666;
            stroke-width: 2;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            margin: 0 10px;
            padding: 5px 10px;
        }
        .info {
            margin: 20px 0;
            padding: 10px;
            background: #e0e0e0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h2>Load Visualization Test</h2>
        
        <div class="info">
            The loads are scaled relative to each other. The largest load will always be at maximum height (60px),
            and other loads will scale proportionally.
        </div>

        <!-- Controls -->
        <div class="controls">
            <button onclick="updateMagnitudes()">Change Magnitudes</button>
            <button onclick="addLoad()">Add Random Load</button>
            <button onclick="removeLastLoad()">Remove Last Load</button>
        </div>

        <!-- SVG Canvas -->
        <svg id="canvas" width="800" height="300"></svg>
    </div>

    <script>
        // Initialize SVG
        const svg = d3.select('#canvas');
        
        // Create a group for the beam and loads, centered vertically
        const mainGroup = svg.append('g')
            .attr('transform', 'translate(0, 150)');
        
        // Add beam
        mainGroup.append('line')
            .attr('class', 'beam-line')
            .attr('x1', 50)
            .attr('y1', 0)
            .attr('x2', 750)
            .attr('y2', 0);

        // LoadRenderer implementation
        class LoadRenderer {
            constructor(svgContainer) {
                this.svg = svgContainer;
                this.MAX_HEIGHT = 60;
                this.TOP_OFFSET = 10;
                this.ARROW_SIZE = 8;
                this.ARROW_OVERLAP = 3;
                this.loads = new Map();
            }

            getMaxMagnitude(type) {
                const loadsOfType = Array.from(this.loads.values())
                    .filter(load => load.type === type);
                
                if (loadsOfType.length === 0) return 1;
                return Math.max(...loadsOfType.map(load => Math.abs(load.magnitude)));
            }

            calculateHeight(magnitude, type) {
                const maxMagnitude = this.getMaxMagnitude(type);
                return (Math.abs(magnitude) / maxMagnitude) * this.MAX_HEIGHT;
            }

            createArrowPath(x, y, size) {
                // Arrow points downward at the bottom of the line
                // Width reduced to ~2/3, centered (±0.67 instead of ±1)
                const halfWidth = size * 0.67;
                return `M ${x} ${y} l ${-halfWidth} ${-size} l ${halfWidth * 2} 0 Z`;
            }

            formatMagnitude(value) {
                return value.toFixed(1);
            }

            updateAllLoads() {
                this.loads.forEach((loadData, loadGroup) => {
                    const height = this.calculateHeight(loadData.magnitude, loadData.type);
                    const d3Group = d3.select(loadGroup);
                    
                    if (loadData.type === 'udl') {
                        const y = -height - this.TOP_OFFSET;
                        const rect = d3Group.select('rect');
                        const width = parseFloat(rect.attr('width'));
                        const startX = parseFloat(rect.attr('x'));
                        const endX = startX + width;

                        rect.transition()
                            .duration(300)
                            .attr('y', y)
                            .attr('height', height);

                        // Update arrows
                        const arrows = d3Group.selectAll('path');
                        arrows.nodes().forEach((arrow, i) => {
                            const x = i === 0 ? startX : endX;
                            d3.select(arrow)
                                .transition()
                                .duration(300)
                                .attr('d', d => this.createArrowPath(x, -this.TOP_OFFSET, this.ARROW_SIZE));
                        });

                        d3Group.select('text')
                            .transition()
                            .duration(300)
                            .attr('y', y - 5)
                            .text(`${this.formatMagnitude(loadData.magnitude)} k/ft`);
                    } else { // point load
                        const y2 = -height - this.TOP_OFFSET;
                        const y1 = -this.TOP_OFFSET - this.ARROW_OVERLAP;
                        
                        d3Group.select('line')
                            .transition()
                            .duration(300)
                            .attr('y1', y1)
                            .attr('y2', y2);

                        d3Group.select('path')
                            .transition()
                            .duration(300)
                            .attr('d', d => this.createArrowPath(d.x, -this.TOP_OFFSET, this.ARROW_SIZE))
                            .attr('fill', d => d.color);

                        d3Group.select('text')
                            .transition()
                            .duration(300)
                            .attr('y', y2 - 5)
                            .text(`${this.formatMagnitude(loadData.magnitude)} k`);
                    }
                });
            }

            renderUDL(params) {
                const {startX, endX, magnitude, color = 'black'} = params;
                const height = this.calculateHeight(magnitude, 'udl');
                const y = -height - this.TOP_OFFSET;
                
                const loadGroup = this.svg.append('g')
                    .attr('class', 'udl-load');

                this.loads.set(loadGroup.node(), {
                    type: 'udl',
                    magnitude: magnitude
                });

                loadGroup.append('rect')
                    .attr('x', startX)
                    .attr('y', y)
                    .attr('width', endX - startX)
                    .attr('height', height)
                    .attr('fill', 'none')
                    .attr('stroke', color)
                    .attr('stroke-width', 2);

                // Left arrow
                loadGroup.append('path')
                    .datum({ x: startX, color: color })
                    .attr('d', d => this.createArrowPath(d.x, -this.TOP_OFFSET, this.ARROW_SIZE))
                    .attr('fill', color)
                    .attr('stroke', 'none');

                // Right arrow
                loadGroup.append('path')
                    .datum({ x: endX, color: color })
                    .attr('d', d => this.createArrowPath(d.x, -this.TOP_OFFSET, this.ARROW_SIZE))
                    .attr('fill', color)
                    .attr('stroke', 'none');

                loadGroup.append('text')
                    .attr('x', startX + (endX - startX) / 2)
                    .attr('y', y - 5)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '12px')
                    .text(`${this.formatMagnitude(magnitude)} k/ft`);

                this.updateAllLoads();
                return loadGroup;
            }

            renderPointLoad(params) {
                const {x, magnitude, color = 'black'} = params;
                const height = this.calculateHeight(magnitude, 'point');
                const y2 = -height - this.TOP_OFFSET;
                const y1 = -this.TOP_OFFSET - this.ARROW_OVERLAP;

                const loadGroup = this.svg.append('g')
                    .attr('class', 'point-load');

                this.loads.set(loadGroup.node(), {
                    type: 'point',
                    magnitude: magnitude
                });

                loadGroup.append('line')
                    .attr('x1', x)
                    .attr('y1', y1)
                    .attr('x2', x)
                    .attr('y2', y2)
                    .attr('stroke', color)
                    .attr('stroke-width', 2);

                loadGroup.append('path')
                    .datum({ x: x, color: color })
                    .attr('d', d => this.createArrowPath(d.x, -this.TOP_OFFSET, this.ARROW_SIZE))
                    .attr('fill', color)
                    .attr('stroke', 'none');

                loadGroup.append('text')
                    .attr('x', x)
                    .attr('y', y2 - 5)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '12px')
                    .text(`${this.formatMagnitude(magnitude)} k`);

                this.updateAllLoads();
                return loadGroup;
            }

            updateMagnitude(loadGroup, newMagnitude) {
                const loadData = this.loads.get(loadGroup.node());
                loadData.magnitude = newMagnitude;
                
                this.updateAllLoads();

                loadGroup.select('text')
                    .text(loadData.type === 'udl' 
                        ? `${this.formatMagnitude(newMagnitude)} k/ft` 
                        : `${this.formatMagnitude(newMagnitude)} k`);
            }

            removeLoad(loadGroup) {
                this.loads.delete(loadGroup.node());
                loadGroup.remove();
                this.updateAllLoads();
            }
        }

        // Create renderer and store loads
        const renderer = new LoadRenderer(mainGroup);
        const loadGroups = [];
        
        // Add some example loads
        loadGroups.push(renderer.renderUDL({
            startX: 100,
            endX: 300,
            magnitude: 2,
            color: '#2563eb'
        }));

        loadGroups.push(renderer.renderPointLoad({
            x: 400,
            magnitude: 5,
            color: '#dc2626'
        }));

        loadGroups.push(renderer.renderUDL({
            startX: 500,
            endX: 650,
            magnitude: 1.5,
            color: '#059669'
        }));

        // Function to update magnitudes
        function updateMagnitudes() {
            loadGroups.forEach(loadGroup => {
                renderer.updateMagnitude(loadGroup, Math.random() * 6 + 1);
            });
        }

        // Function to add a random load
        function addLoad() {
            const isUDL = Math.random() > 0.5;
            const colors = ['#2563eb', '#dc2626', '#059669', '#7c3aed', '#ea580c'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            if (isUDL) {
                const startX = Math.random() * 500 + 100;
                loadGroups.push(renderer.renderUDL({
                    startX: startX,
                    endX: startX + Math.random() * 100 + 50,
                    magnitude: Math.random() * 4 + 1,
                    color: color
                }));
            } else {
                loadGroups.push(renderer.renderPointLoad({
                    x: Math.random() * 600 + 100,
                    magnitude: Math.random() * 6 + 1,
                    color: color
                }));
            }
        }

        // Function to remove the last added load
        function removeLastLoad() {
            if (loadGroups.length > 0) {
                const loadGroup = loadGroups.pop();
                renderer.removeLoad(loadGroup);
            }
        }
    </script>
</body>
</html> 